# -*- coding: utf-8 -*-
"""individual_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r_HnOPaUb-refKz76AtDilpCqbrP165c
"""

import torch
import numpy as np
# from tqdm import tqdm
from tqdm.notebook import tqdm_notebook as tqdm
import torch.nn.functional as F
import torch.nn as nn
import random

import math

import pandas as pd

from models.sleep_model import simple_model
from models.nmf_embed import pad_NMF, sleep_NMF, find_opt_num_feat
from models.early_stopping import EarlyStopping
from models.model_training import model_training
from models.find_threshold import find_optimal_threshold

from data.loader import Dataset
from data.missing_distribution_param_est import params_estimate

def individual_model_handle(dataset_file, mode='handle', param_choice='tune'):

  assert mode in ['evaluate', 'handle'], 'mode should be either evaluate or handle only'
  assert param_choice in ['tune', 'default'], 'param_choice should be either tune or default'
  
  if param_choice == 'tune':
      alpha, beta = params_estimate('data/' + dataset_file)
  elif param_choice == 'default':
      alpha = 1.11
      beta = 31.09

  # read the data 
  Data = pd.read_csv('data/' + dataset_file)
  # the dataset_file should have SleepStatus and actigraphy in its columns
  assert 'SleepStatus' in Data.columns, 'The file should have SleepStatus column'
  assert 'actigraphy' in Data.columns, 'The file should have actigraphy column'

  Data['Label'] = Data['SleepStatus'].apply(lambda x: 0 if x == 'Sleep' else 1.)
  Data['denote'] = Data['actigraphy'].apply(lambda x: 0. if np.isnan(x) else 1.)
  
  shape=Data.shape[0]
  # if evaluate, then we create a testing mask to evaluate models' performance

  if mode == 'evaluate':
    for i in range(50):
      getrandom = random.randint(0, shape)
      xd = np.random.gamma(alpha, beta, 1)[0]
      Data.loc[getrandom: min(getrandom+xd, Data.shape[0]), 'denote'] = 0

  # Mark the types of the missing interval 
  fillmisscol = np.full((Data.shape[0]), 0)
  i = 0
  while i < Data.shape[0]:
    if Data['denote'][i] == 0:
      counter = 1
      while i + counter < Data.shape[0] and Data['denote'][i + counter] == 0:
        counter += 1
      fillmisscol[i:i+counter] = counter
      i = i + counter
    else:
      i += 1

  Data['type'] = fillmisscol // 30 + 1
  Data.loc[ fillmisscol==0 , 'type'] = 0

  Data['denote_true'] = Data['denote']

  # Generate artificial missing data for training
  for i in range(50):
    getrandom = random.randint(0, Data.shape[0])
    xd = np.random.gamma(alpha, beta, 1)[0]
    Data.loc[getrandom: min(getrandom+xd, Data.shape[0]), 'denote'] = 0
  Data.loc[Data['denote'] == 0, 'actigraphy'] = np.nan
  thresh = np.quantile(Data[~Data['actigraphy'].isnull()]['actigraphy'], 0.9)
  Data.loc[:, 'actigraphy'] = Data['actigraphy'].apply(lambda x: 1 if x > thresh else x/thresh)
  # NMF
  slp_data = pad_NMF(Data)
  NMF_info = sleep_NMF(slp_data, Data)
  Data['NMF'] = NMF_info.reshape(-1)[:Data.shape[0]]
  # Add the denotations and split the data into training and testing 
  Data['known_label'] = Data['Label']
  Data.loc[Data['denote'] == 0, 'known_label'] = 0
  Data.loc[Data['denote'] == 0, 'actigraphy'] = -1
  traindata = Data[Data['denote_true'] == 1]
  testdata = Data[Data['denote_true'] == 0]

  # Create Dataset for training and validation
  X_train = traindata[['actigraphy', 'denote', 'NMF', 'known_label']].to_numpy()
  y_train = traindata['Label']

  thresh = int(X_train.shape[0]*0.8)

  X_valid = X_train[thresh:, :]
  y_valid = y_train[thresh:]

  X_train = X_train[:thresh, :]
  y_train = y_train[:thresh]

  X_test = testdata[['actigraphy', 'denote', 'NMF', 'known_label']].to_numpy()
  y_test = testdata['Label']

  X_train = torch.tensor(X_train)#.to(device)
  X_test = torch.tensor(X_test)#.to(device)
  X_valid = torch.tensor(X_valid)

  y_train = torch.tensor(y_train.values)#.to(device)
  y_test = torch.tensor(y_test.values)#.to(device)
  y_valid = torch.tensor(y_valid.values)#.to(device)

  # Get the weights for training
  sleep_weight = y_train.shape[0]/ (2* y_train[y_train == 0].shape[0])
  wake_weight =  y_train.shape[0]/ (2* y_train[y_train == 1].shape[0])

  # Create data generator
  device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
  params = {'batch_size': 64,
            'shuffle': True,
            'num_workers': 2}

  training_set = Dataset(X_train, y_train)
  training_generator = torch.utils.data.DataLoader(training_set, **params)

  valid_set = Dataset(X_valid, y_valid)
  valid_generator = torch.utils.data.DataLoader(valid_set, **params)

  model = model_training(training_generator, valid_generator, device, sleep_weight, wake_weight)

  result = model(torch.Tensor(Data[['actigraphy', 'denote', 'NMF', 'known_label']].to_numpy()).float().to(device))[:, 1]
  dfvalid = pd.DataFrame()
  dfvalid['prob'] = result.detach().cpu().numpy()
  dfvalid['ground'] = Data['Label'].values
  dfvalid['type'] = Data['type']

  threshold = find_optimal_threshold(dfvalid[dfvalid['type'] == 0 ]['ground'], dfvalid[dfvalid['type'] == 0 ]['prob'])

  dfvalid['pred'] = dfvalid['prob'].apply(lambda x: 1 if x>=threshold else 0)
  dfvalid['acti'] = Data['actigraphy'].values
  dfvalid['NMF'] = Data['NMF'].values
  dfvalid['denote'] = Data['denote_true']

  if mode == 'evaluate':
    for i in [[1,2], [3, 4, 5, 6], [7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]:
      print('------------------------------------')
      all0 = dfvalid[(dfvalid['ground'] == 0) & (dfvalid['type'].isin(i)) & (Data['denote_true'] == 0)].shape[0]
      all1 = dfvalid[(dfvalid['ground'] == 1) & (dfvalid['type'].isin(i)) & (Data['denote_true'] == 0)].shape[0]
      tp = dfvalid[(dfvalid['ground'] == 0) & (dfvalid['type'].isin(i)) & (dfvalid['pred'] == 0) & (Data['denote_true'] == 0)].shape[0]
      tn = dfvalid[(dfvalid['ground'] == 1) & (dfvalid['type'].isin(i)) & (dfvalid['pred'] == 1) & (Data['denote_true'] == 0)].shape[0]
      print('Type ', [[1,2], [3, 4, 5, 6], [7, 8, 9, 10, 11, 12, 13, 14, 15, 16]].index(i) + 1)
      print('Total_sleep: ', all0)

      if all0 > 0:
        print('AccSleep: ', tp/all0)
      
      print('Total_wake: ',  all1)
      if all1 > 0:
        print('AccWake: ', tn/all1)

  return dfvalid

